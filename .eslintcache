[{"/home/ejnshtein/projects/mangadex-api/src/Agent.js":"1","/home/ejnshtein/projects/mangadex-api/src/Composer.js":"2","/home/ejnshtein/projects/mangadex-api/src/Mangadex.js":"3","/home/ejnshtein/projects/mangadex-api/src/Scraper.js":"4","/home/ejnshtein/projects/mangadex-api/src/index.js":"5","/home/ejnshtein/projects/mangadex-api/src/lib/deepmerge.js":"6","/home/ejnshtein/projects/mangadex-api/src/lib/error.js":"7","/home/ejnshtein/projects/mangadex-api/src/lib/index.js":"8","/home/ejnshtein/projects/mangadex-api/src/lib/links.js":"9","/home/ejnshtein/projects/mangadex-api/src/lib/multipart.js":"10","/home/ejnshtein/projects/mangadex-api/src/lib/sleep.js":"11"},{"size":9854,"mtime":1600540828580,"results":"12","hashOfConfig":"13"},{"size":1360,"mtime":1600533743465,"results":"14","hashOfConfig":"13"},{"size":7742,"mtime":1600533933057,"results":"15","hashOfConfig":"13"},{"size":11299,"mtime":1599942820842,"results":"16","hashOfConfig":"13"},{"size":226,"mtime":1599947128018,"results":"17","hashOfConfig":"13"},{"size":599,"mtime":1599947480538,"results":"18","hashOfConfig":"13"},{"size":313,"mtime":1599595384867,"results":"19","hashOfConfig":"13"},{"size":123,"mtime":1600531403199,"results":"20","hashOfConfig":"13"},{"size":861,"mtime":1599947718344,"results":"21","hashOfConfig":"13"},{"size":340,"mtime":1599595384867,"results":"22","hashOfConfig":"13"},{"size":81,"mtime":1599595384867,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1r7iogk",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"33","messages":"34","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"35","messages":"36","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"37","messages":"38","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/ejnshtein/projects/mangadex-api/src/Agent.js",[],"/home/ejnshtein/projects/mangadex-api/src/Composer.js",[],"/home/ejnshtein/projects/mangadex-api/src/Mangadex.js",["47"],"const Scraper = require('./Scraper')\nconst Agent = require('./Agent')\nconst Composer = require('./Composer')\nconst deepmerge = require('./lib/deepmerge')\n\nconst DefaultOptions = {\n  host: 'https://mangadex.org',\n  apiHost: 'https://mangadex.org/api'\n}\n\nclass Mangadex {\n  constructor (options = {}) {\n    this.options = Object.assign({}, DefaultOptions, options)\n\n    this.agent = new Agent({\n      host: this.options.host,\n      apiHost: this.options.apiHost,\n      getCredentials: this.options.getCredentials\n    })\n  }\n\n  async getManga (mangaId, params = {}) {\n    const { data } = await Agent.callApi(`manga/${mangaId}`, {\n      baseUrl: this.options.host,\n      ...params\n    })\n\n    return normalizeManga({ ...data, host: this.options.host })\n  }\n\n  static async getManga (mangaId, params = {}) {\n    const { data } = await Agent.callApi(`manga/${mangaId}`, params)\n    return normalizeManga({ ...data, host: params.baseUrl })\n  }\n\n  async getChapter (chapterId, params = {}) {\n    const { data } = await Agent.callApi(`chapter/${chapterId}`, {\n      baseUrl: this.options.host,\n      ...params\n    })\n\n    return normalizeChapter(data, `${this.options.host}/data/`)\n  }\n\n  static async getChapter (chapterId, params = {}) {\n    const { data } = await Agent.callApi(`chapter/${chapterId}`, params)\n    return normalizeChapter(\n      data,\n      params.defaultServer || `${DefaultOptions.host}/data/`\n    )\n  }\n\n  async search (query, params = {}) {\n    const defaultQuery = {\n      title: '',\n      author: '',\n      artist: '',\n      lang_id: null,\n      demos: [],\n      statuses: [],\n      tags: [],\n      tag_mode_inc_all: 'all',\n      tag_mode_exc: 'any'\n    }\n\n    if (typeof query === 'string') {\n      defaultQuery.title = query\n    } else if (typeof query === 'object') {\n      Object.entries(query).forEach(([name, value]) => {\n        if (typeof value === 'string' && value) {\n          defaultQuery[name] = value\n        }\n        if (Array.isArray(value) && value.length > 0) {\n          defaultQuery[name] = value.join(',')\n        }\n      })\n    }\n    const finalParams = Object.entries(defaultQuery).reduce(\n      (acc, [name, value]) => {\n        if (typeof value === 'string' && value) {\n          acc[name] = value\n        }\n        if (Array.isArray(value) && value.length > 0) {\n          acc[name] = value.join(',')\n        }\n        return acc\n      },\n      {}\n    )\n\n    const result = await this.agent.call(\n      'search',\n      deepmerge(params, {\n        params: finalParams\n      })\n    )\n\n    return Scraper.parseSearch(result, this.options.host)\n  }\n\n  static async search (query = {}, params = {}) {\n    const defaultQuery = {\n      title: '',\n      author: '',\n      artist: '',\n      lang_id: null,\n      demos: [],\n      statuses: [],\n      tags: [],\n      tag_mode_inc_all: 'all',\n      tag_mode_exc: 'any'\n    }\n\n    if (typeof query === 'string') {\n      defaultQuery.title = query\n    } else if (typeof query === 'object') {\n      Object.entries(query).forEach(([name, value]) => {\n        if (typeof value === 'string' && value) {\n          defaultQuery[name] = value\n        }\n        if (Array.isArray(value) && value.length > 0) {\n          defaultQuery[name] = value.join(',')\n        }\n      })\n    }\n\n    const finalParams = Object.entries(defaultQuery).reduce(\n      (acc, [name, value]) => {\n        if (typeof value === 'string' && value) {\n          acc[name] = value\n        }\n        if (Array.isArray(value) && value.length > 0) {\n          acc[name] = value.join(',')\n        }\n        return acc\n      },\n      {}\n    )\n\n    const result = await Agent.call(\n      'search',\n      deepmerge(params, {\n        params: finalParams\n      })\n    )\n\n    return Scraper.parseSearch(result.data)\n  }\n\n  async quickSearch (title, params = {}) {\n    const result = await this.agent.call(\n      `quick_search/${encodeURIComponent(title)}`,\n      params\n    )\n    return Scraper.parseSearch(result)\n  }\n\n  static async quickSearch (title, params = {}) {\n    const result = await Agent.call(\n      `quick_search/${encodeURIComponent(title)}`,\n      params\n    )\n    return Scraper.parseSearch(result.data)\n  }\n\n  async getUser (id, params = {}) {\n    const result = await this.agent.call(`user/${id}`, params)\n    return Scraper.parseUser(result)\n  }\n\n  static async getUser (id, params = {}) {\n    const result = await Agent.call(`user/${id}`, params)\n    return Scraper.parseUser(result.data)\n  }\n\n  async getGroup (id, params = {}) {\n    const result = await this.agent.call(`group/${id}`, params)\n    return Scraper.parseGroup(result)\n  }\n\n  static async getGroup (id, params = {}) {\n    const result = await Agent.call(`group/${id}`, params)\n    return Scraper.parseGroup(result.data)\n  }\n\n  async getHome (params = {}) {\n    const result = await this.agent.call('', params)\n    return Scraper.parseHome(result, this.options.host)\n  }\n\n  static async getHome (params = {}) {\n    const result = await Agent.call('', params)\n    return Scraper.parseHome(result.data, params.baseUrl || DefaultOptions.host)\n  }\n\n  async getMe (params = {}) {\n    const result = await this.agent.call('', params)\n    const { id } = Scraper.parseMe(result)\n\n    if (id) {\n      return this.getUser(id)\n    } else {\n      throw new Error('User not found')\n    }\n  }\n\n  async getMangaFollows (params = {}) {\n    const { result } = await this.agent.callApi(\n      '',\n      deepmerge(params, {\n        params: { type: 'manga_follows' }\n      })\n    )\n    return result\n  }\n\n  async friendAdd (userId, params = {}) {\n    await this.agent.callAjaxAction(\n      {\n        function: 'friend_add',\n        id: userId\n      },\n      params\n    )\n\n    return true\n  }\n\n  async mangaFollow (mangaId, type, params = {}) {\n    await this.agent.callAjaxAction(\n      {\n        function: 'manga_follow',\n        id: mangaId,\n        type\n      },\n      params\n    )\n\n    return true\n  }\n\n  async mangaUnfollow (mangaId, params = {}) {\n    await this.agent.callAjaxAction(\n      {\n        function: 'manga_unfollow',\n        id: mangaId,\n        type: mangaId\n      },\n      params\n    )\n\n    return true\n  }\n}\n\nmodule.exports = Mangadex\n\nconst normalizeManga = ({ manga, group, chapter, status, host }) => {\n  if (typeof chapter === 'object') {\n    const fixedChapters = Object.keys(chapter)\n      .map((id) => ({\n        id: Number.parseInt(id),\n        lang_name: Composer.getLangName(chapter[id].lang_code),\n        ...chapter[id]\n      }))\n      .sort((a, b) => Number(a.chapter) - Number(b.chapter))\n    chapter = fixedChapters\n  }\n  if (typeof group === 'object') {\n    const fixedGroups = Object.entries(group).map(\n      ([groupId, { group_name }]) => ({\n        id: Number.parseInt(groupId),\n        name: group_name\n      })\n    )\n    group = fixedGroups\n  }\n  manga.cover_url = `${host || 'https://mangadex.org'}${manga.cover_url}`\n  if (typeof manga.genres === 'object' && manga.genres !== null) {\n    manga.genres = Composer.getGenres(manga.genres)\n  }\n  if (typeof manga.status === 'number') {\n    manga.status_text = Composer.getStatus(manga.status)\n  }\n  if (typeof manga.links === 'object' && manga.links !== null) {\n    manga.links = Composer.getMangaLinks(manga.links)\n  }\n  if (typeof manga.description === 'string') {\n    manga.description = Composer.parseToHTML(manga.description)\n  }\n  return {\n    manga,\n    chapter,\n    group,\n    status\n  }\n}\n\nconst normalizeChapter = (\n  chapter,\n  defaultServer = 'https://mangadex.org/data/'\n) => {\n  if (chapter.server === '/data/') {\n    chapter.server = defaultServer\n  }\n  if (typeof chapter.page_array === 'object') {\n    chapter.page_array = chapter.page_array.map(\n      (page) => `${chapter.server}${chapter.hash}/${page}`\n    )\n  }\n  return chapter\n}\n","/home/ejnshtein/projects/mangadex-api/src/Scraper.js",[],"/home/ejnshtein/projects/mangadex-api/src/index.js",[],"/home/ejnshtein/projects/mangadex-api/src/lib/deepmerge.js",[],"/home/ejnshtein/projects/mangadex-api/src/lib/error.js",[],"/home/ejnshtein/projects/mangadex-api/src/lib/index.js",[],"/home/ejnshtein/projects/mangadex-api/src/lib/links.js",[],"/home/ejnshtein/projects/mangadex-api/src/lib/multipart.js",[],"/home/ejnshtein/projects/mangadex-api/src/lib/sleep.js",[],{"ruleId":"48","severity":1,"message":"49","line":271,"column":20,"nodeType":"50","messageId":"51","endLine":271,"endColumn":30},"camelcase","Identifier 'group_name' is not in camel case.","Identifier","notCamelCase"]